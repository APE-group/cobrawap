configfile: "configfile.yaml"

from settings import working_dir, data_path, metadata_path, output_path, figure_path, script_path

workdir: working_dir

### Ephys parameters
FREQ_BAND = config["FREQ_BAND"]
MIN_STATE_DURATION = config["MIN_STATE_DURATION"]
FIXED_THRESHOLD = config["FIXED_THRESHOLD"]
SIGMA_THRESHOLD = config["SIGMA_THRESHOLD"]
DETRENDING_ORDER = config["DETRENDING_ORDER"]
PSD_FREQ_RES = config["PSD_FREQ_RES"]
PSD_OVERLAP = config["PSD_OVERLAP"]
SLOPE_WINDOW = config["SLOPE_WINDOW"]

## Optical parameters
CONTOUR_LIMIT = config["CONTOUR_LIMIT"]
MACRO_PIXEL_DIM = config["MACRO_PIXEL_DIM"]
SAVE_IMAGE_FORMAT = 'png'
# ToDo: isolate loading routine
# ToDo: structure output folder structure
# ToDo: integrate optical parameters into configfile
# ToDo: separate optical and ephys config/rules/...?

########################## Optical rules ##########################
# localrules: check_parameters

# if '--nolock' not in sys.argv:
#     from check_parameters import check_parameters
#     check_parameters(config)

rule find_contour:
    input:
        image_file = os.path.join(data_path, '{image_path}','{image_name}.tif'),
        script = 'scripts/find_image_contour.py'
    params:
        contour_limit = CONTOUR_LIMIT
    output:
        contour = os.path.join(output_path, '{image_path}', 'contour_{image_name}.npy'),
        mask = os.path.join(output_path, '{image_path}', 'mask_{image_name}.npy'),
        image = os.path.join(output_path, '{image_path}', 'contour_{image_name}' + '.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_file} \
                              --output_contour {output.contour} \
                              --output_mask {output.mask} \
                              --output_image {output.image} \
                              --contour_limit {params.contour_limit} \
        """

def image_files(wildcards):
    return expand(os.path.join(data_path, '{image_path}', '{file_name}.tif'),
                  image_path=wildcards.image_path,
                  file_name=glob_wildcards(os.path.join(data_path, '{image_path}', '{file_name}.tif')).file_name)

rule calculate_background:
    input:
        image_files = image_files,
        script = 'scripts/calculate_background_image.py'
    output:
        background = os.path.join(output_path, '{image_path}', 'background.npy'),
        image = os.path.join(output_path, '{image_path}', 'background.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_files {input.image_files} \
                              --output_background {output.background} \
                              --output_image {output.image} \
        """

rule initialize_image:
    input:
        image_file = os.path.join(data_path, '{image_path}','{image_name}.tif'),
        background = rules.calculate_background.output.background,
        mask = rules.find_contour.output.mask,
        script = "scripts/initialize_image.py",
        configfile = "configfile.yaml"
    params:
        macro_pixel_dim = MACRO_PIXEL_DIM
    output:
        array = os.path.join(output_path, '{image_path}', 'images/', '{image_name}_initialized.npy'),
        image = os.path.join(output_path, '{image_path}', 'images/', '{image_name}_initialized'+'.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_file} \
                              --background {input.background} \
                              --mask {input.mask} \
                              --macro_pixel_dim {params.macro_pixel_dim} \
                              --output_array {output.array} \
                              --output_image {output.image} \
        """

    # What it does:
    # Finds contour on first image, applies as mask to every image
    # calculates background (sum), subtracts from every image
    # spatial smoothing on block of images
    # saving the images as txt

########################## Ephys rules ##########################



rule load_enrich_save_neo:
    input:
        data = os.path.join(data_path, '{data_file}.smr'),
        metadata = metadata_path,
        script = script_path + "load_and_transform_to_neo.py"
    params:
        metadata_dir = os.path.dirname(metadata_path)
    conda:
        "envs/wavescalephant_env.yml"
    output:
        os.path.join(output_path, '{data_file}.nix')
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.metadata_dir}'
        python {input.script} --output {output} --data {input.data} \
                              --metadata {input.metadata}
        """


rule log_MUA_estimation:
    input:
        data = {rules.load_enrich_save_neo.output},
        script = script_path + "log_MUA_estimation.py",
        configfile = "configfile.yaml"
    params:
        script_path = script_path,
        freq_band = FREQ_BAND,
        detrending_order = DETRENDING_ORDER,
        psd_overlap = PSD_OVERLAP
    conda:
        "envs/wavescalephant_env.yml"
    output:
        output_path + "logMUA.nix"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} \
                              --data {input.data} \
                              --freq_band {params.freq_band} \
                              --detrending_order {params.detrending_order} \
                              --psd_overlap {params.psd_overlap}
        """


rule UpDown_detection:
    input:
        logMUA = {rules.log_MUA_estimation.output},
        script = script_path + "UpDown_detection.py"
    params:
        min_state_duration = MIN_STATE_DURATION,
        fixed_threshold = FIXED_THRESHOLD,
        sigma_threshold = SIGMA_THRESHOLD,
        script_path = script_path,
        show_plots = 0
    conda:
        "envs/wavescalephant_env.yml"
    output:
        output_path + "UD_state_vector.npy"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --logMUA_estimate {input.logMUA} \
                              --min_state_duration {params.min_state_duration} \
                              --fixed_threshold {params.fixed_threshold} \
                              --sigma_threshold {params.sigma_threshold} \
                              --show_plots {params.show_plots}
        """


########################## Plotting rules ##########################

rule plot_signal_traces:
    input:
        data = {rules.load_enrich_save_neo.output},
        script = script_path + "plot_signal_traces.py"
    params:
        scaling = 12,
        show_figure = 0,
        script_path = script_path
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "lfp_traces_t{t_start}-{t_stop}s.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        echo {params.show_figure}
        python {input.script} --output {output} --data {input.data} \
                              --format {wildcards.format} --scaling {params.scaling} \
                              --t_start {wildcards.t_start} --t_stop {wildcards.t_stop} \
                              --show_figure {params.show_figure}
        """


rule plot_power_spectrum:
    input:
        data = {rules.load_enrich_save_neo.output},
        script = script_path + "plot_power_spectrum.py"
    params:
        show_figure = 0,
        psd_freq_res = PSD_FREQ_RES,
        psd_overlap = PSD_OVERLAP,
        script_path = script_path
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "power_spectrum.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --data {input.data} \
                              --format {wildcards.format} --psd_freq_res {params.psd_freq_res} \
                              --psd_overlap {params.psd_overlap} \
                              --show_figure {params.show_figure}

        """


rule plot_logMUA_states:
    input:
        logMUA = {rules.log_MUA_estimation.output},
        data = {rules.load_enrich_save_neo.output},
        UD_states = {rules.UpDown_detection.output},
        script = script_path + 'plot_logMUA_states.py'
    params:
        script_path = script_path,
        show_figure = 1
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "logMUA_states_channel{channel}_{t_start}-{t_stop}s.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --logMUA {input.logMUA} \
                              --data {input.data} \
                              --UD_states {input.UD_states} \
                              --channel {wildcards.channel} \
                              --format {wildcards.format} \
                              --t_start {wildcards.t_start} \
                              --t_stop {wildcards.t_stop} \
                              --show_figure {params.show_figure}
        """


rule plot_avg_slopes:
    input:
        logMUA = {rules.log_MUA_estimation.output},
        UD_states = {rules.UpDown_detection.output},
        script = script_path + "plot_avg_transitions.py"
    params:
        script_path = script_path,
        slope_window = SLOPE_WINDOW,
        show_figure = 1
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "UD_slopes_channel{channel}.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --logMUA_estimate {input.logMUA} \
                              --state_vector {input.UD_states} --show_figure {params.show_figure} \
                              --slope_window {params.slope_window} --channel {wildcards.channel} \
                              --format {wildcards.format}
        """
