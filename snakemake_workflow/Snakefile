configfile: "configfile.yaml"

from settings import working_dir, data_path, metadata_path, output_path, figure_path, script_path
import numpy as np

workdir: working_dir

### Ephys parameters
FREQ_BAND = config["FREQ_BAND"]
MIN_STATE_DURATION = config["MIN_STATE_DURATION"]
FIXED_THRESHOLD = config["FIXED_THRESHOLD"]
SIGMA_THRESHOLD = config["SIGMA_THRESHOLD"]
DETRENDING_ORDER = config["DETRENDING_ORDER"]
PSD_FREQ_RES = config["PSD_FREQ_RES"]
PSD_OVERLAP = config["PSD_OVERLAP"]
SLOPE_WINDOW = config["SLOPE_WINDOW"]

## Optical parameters
FRAME_NUM_REGEX = config["FRAME_NUM_REGEX"]
CONTOUR_LIMIT = config["CONTOUR_LIMIT"]
CONTOUR_FRAME = config["CONTOUR_FRAME"]
MACRO_PIXEL_DIM = config["MACRO_PIXEL_DIM"]
NORMALIZE_BY = config["NORMALIZE_BY"]
TIME_START = config["TIME_START"]
TIME_STOP = config["TIME_STOP"]
IMG_PATH = config["IMG_PATH"]
SAMPLING_RATE = config["SAMPLING_RATE"]
PIXEL_SIZE = config["PIXEL_SIZE"]
SAVE_IMAGE_FORMAT = 'png'
CONTOUR_FRAME = 1
# ToDo: isolate loading routine
# ToDo: structure output folder structure
# ToDo: integrate optical parameters into configfile
# ToDo: separate optical and ephys config/rules/...?

########################## Optical rules ##########################
# localrules: check_parameters

# if '--nolock' not in sys.argv:
#     from check_parameters import check_parameters
#     check_parameters(config)

def input_images(location):
    def image_files(wildcards):
        return expand(os.path.join(location, '{image_path}', '{file_name}.tif'),
                      image_path=wildcards.image_path,
                      file_name=glob_wildcards(os.path.join(location, '{image_path}', '{file_name}.tif')).file_name)
    return image_files


rule find_contour:
    input:
        image_nix = os.path.join(output_path, '{image_path}', 'images.nix'),
        script = 'scripts/find_image_contour.py'
    params:
        contour_limit = CONTOUR_LIMIT,
        contour_frame = CONTOUR_FRAME
    output:
        contour = os.path.join(output_path, '{image_path}', 'contour.npy'),
        mask = os.path.join(output_path, '{image_path}', 'mask.npy'),
        image = os.path.join(output_path, '{image_path}', 'contour.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --output_contour {output.contour} \
                              --output_mask {output.mask} \
                              --output_image {output.image} \
                              --contour_limit {params.contour_limit} \
                              --contour_frame {params.contour_frame}
        """


rule calculate_background:
    input:
        image_nix = os.path.join(output_path,
                                 '{image_path}', 'images.nix'),
        script = 'scripts/calculate_background_image.py'
    output:
        background = os.path.join(output_path,
                                  '{image_path}', 'background.npy'),
        image = os.path.join(output_path, '{image_path}',
                             'background.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --output_background {output.background} \
                              --output_image {output.image} \
        """

rule preprocess_images:
    input:
        image_nix = os.path.join(output_path,
                                 '{image_path}', 'images.nix'),
        background = os.path.join(output_path,
                                  '{image_path}', 'background.npy'),
        mask = os.path.join(output_path, '{image_path}', 'mask.npy'),
        script = "scripts/preprocess_images.py",
        configfile = "configfile.yaml"
    params:
        macro_pixel_dim = MACRO_PIXEL_DIM,
        normalize_by = NORMALIZE_BY
    output:
        os.path.join(output_path, '{image_path}', 'preprocessed_images.nix')
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --background {input.background} \
                              --mask {input.mask} \
                              --macro_pixel_dim {params.macro_pixel_dim} \
                              --normalize_by {params.normalize_by} \
                              --output {output} \
        """


rule images_to_movie:
    input:
        image_nix = os.path.join(output_path, '{image_path}', 'preprocessed_images.nix'),
        script = "scripts/imaging_movie.py"
    params:
        fps = 5,
        frame_name = 'frame',
        frame_format = SAVE_IMAGE_FORMAT,
        quality = 31,
        scale_x = 1080,
        scale_y = 1080
    output:
        frame_folder = directory(os.path.join(output_path, '{image_path}', 'frames')),
        movie = os.path.join(output_path, '{image_path}', 'preprocessed_images.mp4')
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --frame_folder {output.frame_folder} \
                              --out_movie {output.movie} \
                              --fps {params.fps} \
                              --frame_format {params.frame_format} \
                              --frame_name {params.frame_name} \
                              --quality {params.quality} \
                              --scale_x {params.scale_x} \
                              --scale_y {params.scale_y} \
        """


rule images_to_analogsignal:
    input:
        images = input_images(data_path), #/{image_path}/*.tif
        script = 'scripts/image_to_analogsignal.py'
    params:
        sampling_rate = SAMPLING_RATE,
        t_start = TIME_START,
        t_stop = TIME_STOP,
        pixel_size = PIXEL_SIZE,
        frame_num_regex = [[FRAME_NUM_REGEX]]
    output:
        norm_signal = os.path.join(output_path, '{image_path}', 'images.nix')
    shell:
        """
        python {input.script} --image_files {input.images} \
                              --output {output} \
                              --sampling_rate {params.sampling_rate} \
                              --t_start {params.t_start} \
                              --t_stop {params.t_stop} \
                              --pixel_size {params.pixel_size} \
                              --frame_num_regex {params.frame_num_regex}
        """

rule image_spectrum:
    input:
        image_nix = os.path.join(output_path, '{image_path}',
                                 'preprocessed_images.nix'),
        script = "scripts/image_spectrum.py"
    params:
        sampling_rate = SAMPLING_RATE,
        psd_freq_res = 0.1,
        psd_overlap = 0.8
    output:
        spectrum = os.path.join(output_path, '{image_path}', 'spectrum.npy'),
        spectrum_plot = os.path.join(output_path, '{image_path}',
                       'spectrum_plot.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --out_spectrum {output.spectrum} \
                              --out_plot {output.spectrum_plot} \
                              --sampling_rate {params.sampling_rate} \
                              --psd_freq_res {params.freq_res} \
                              --psd_overlap {params.freq_overlap} \
        """

# rule detect_minima:
#     # bandpass filter (interactive if None in config?)
#     # interpolate minima
#     # save + plot
#     input:
#         image_nix = os.path.join(output_path, '{image_path}',
#                                  'preprocessed_images.nix'),
#         script = "scripts/imaging_detect_minima.py"
#     params:
#         lowcut = BUTTER_LOWCUT,
#         highcut = BUTTER_HIGHCUT,
#         order = BUTTER_ORDER,
#         # zoom =
#         # num_points =
#     output:
#         image = os.path.join(output_path, '{image_path}',
#                         'filtered_avg_signal.{}'.format(SAVE_IMAGE_FORMAT))
#         up_transition = os.path.join(output_path, '{image_path}',
#                                      'UP_transitions.nix')
#     shell:
#         """
#         python {input.script} --image_file {input.image_nix} \
#                               --out_image {output.image} \
#                               --out_signal {output.up_transition} \
#                               --lowcut {params.lowcut} \
#                               --highcut {params.highcut} \
#                               --order {params.order}
#         """

########################## Ephys rules ##########################

rule load_enrich_save_neo:
    input:
        data = os.path.join(data_path, '{data_file}.smr'),
        metadata = metadata_path,
        script = script_path + "load_and_transform_to_neo.py"
    params:
        metadata_dir = os.path.dirname(metadata_path)
    conda:
        "envs/wavescalephant_env.yml"
    output:
        os.path.join(output_path, '{data_file}_smr.nix')
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.metadata_dir}'
        python {input.script} --output {output} --data {input.data} \
                              --metadata {input.metadata}
        """


rule log_MUA_estimation:
    input:
        data = {rules.load_enrich_save_neo.output},
        script = script_path + "log_MUA_estimation.py",
        configfile = "configfile.yaml"
    params:
        script_path = script_path,
        freq_band = FREQ_BAND,
        detrending_order = DETRENDING_ORDER,
        psd_overlap = PSD_OVERLAP
    conda:
        "envs/wavescalephant_env.yml"
    output:
        output_path + "logMUA.nix"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} \
                              --data {input.data} \
                              --freq_band {params.freq_band} \
                              --detrending_order {params.detrending_order} \
                              --psd_overlap {params.psd_overlap}
        """


rule UpDown_detection:
    input:
        logMUA = {rules.log_MUA_estimation.output},
        script = script_path + "UpDown_detection.py"
    params:
        min_state_duration = MIN_STATE_DURATION,
        fixed_threshold = FIXED_THRESHOLD,
        sigma_threshold = SIGMA_THRESHOLD,
        script_path = script_path,
        show_plots = 0
    conda:
        "envs/wavescalephant_env.yml"
    output:
        output_path + "UD_state_vector.npy"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --logMUA_estimate {input.logMUA} \
                              --min_state_duration {params.min_state_duration} \
                              --fixed_threshold {params.fixed_threshold} \
                              --sigma_threshold {params.sigma_threshold} \
                              --show_plots {params.show_plots}
        """


########################## Plotting rules ##########################

rule plot_signal_traces:
    input:
        data = {rules.load_enrich_save_neo.output},
        script = script_path + "plot_signal_traces.py"
    params:
        scaling = 12,
        show_figure = 0,
        script_path = script_path
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "lfp_traces_t{t_start}-{t_stop}s.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        echo {params.show_figure}
        python {input.script} --output {output} --data {input.data} \
                              --format {wildcards.format} --scaling {params.scaling} \
                              --t_start {wildcards.t_start} --t_stop {wildcards.t_stop} \
                              --show_figure {params.show_figure}
        """


rule plot_power_spectrum:
    input:
        data = {rules.load_enrich_save_neo.output},
        script = script_path + "plot_power_spectrum.py"
    params:
        show_figure = 0,
        psd_freq_res = PSD_FREQ_RES,
        psd_overlap = PSD_OVERLAP,
        script_path = script_path
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "power_spectrum.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --data {input.data} \
                              --format {wildcards.format} --psd_freq_res {params.psd_freq_res} \
                              --psd_overlap {params.psd_overlap} \
                              --show_figure {params.show_figure}

        """


rule plot_logMUA_states:
    input:
        logMUA = {rules.log_MUA_estimation.output},
        data = {rules.load_enrich_save_neo.output},
        UD_states = {rules.UpDown_detection.output},
        script = script_path + 'plot_logMUA_states.py'
    params:
        script_path = script_path,
        show_figure = 1
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "logMUA_states_channel{channel}_{t_start}-{t_stop}s.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --logMUA {input.logMUA} \
                              --data {input.data} \
                              --UD_states {input.UD_states} \
                              --channel {wildcards.channel} \
                              --format {wildcards.format} \
                              --t_start {wildcards.t_start} \
                              --t_stop {wildcards.t_stop} \
                              --show_figure {params.show_figure}
        """


rule plot_avg_slopes:
    input:
        logMUA = {rules.log_MUA_estimation.output},
        UD_states = {rules.UpDown_detection.output},
        script = script_path + "plot_avg_transitions.py"
    params:
        script_path = script_path,
        slope_window = SLOPE_WINDOW,
        show_figure = 1
    conda:
        "envs/wavescalephant_env.yml"
    output:
        figure_path + "UD_slopes_channel{channel}.{format}"
    shell:
        """
        export PYTHONPATH='$PYTHONPATH:{params.script_path}'
        python {input.script} --output {output} --logMUA_estimate {input.logMUA} \
                              --state_vector {input.UD_states} --show_figure {params.show_figure} \
                              --slope_window {params.slope_window} --channel {wildcards.channel} \
                              --format {wildcards.format}
        """
