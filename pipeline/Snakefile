configfile: "config.yaml"
report: "report.rst"

import os
import sys
import yaml
import numpy as np
sys.path.append('../')
from settings import output_path

# the working directory is by default the directory of the Snakefile
working_dir = ''

STAGES = config["STAGES"]

def read_stage_output(stage, output_namespace="STAGE_OUTPUT"):
    with open(os.path.join(working_dir, stage, 'config.yaml'), 'r') as f:
        config_dict = yaml.safe_load(f)
    if output_namespace in config_dict.keys():
        return os.path.join(output_path, stage, config_dict[output_namespace])
    else:
        raise ValueError(f"config file of stage {stage} "
                       + f"does not define {output_namespace}!")

def create_temp_configs(stages, file_name='temp_config.yaml'):
    for i, stage in enumerate(stages):
        config_path = os.path.join(working_dir, stage, 'config.yaml')
        new_config_path = os.path.join(working_dir, stage, file_name)
        with open(config_path, 'r') as f:
            config_dict = yaml.safe_load(f)
        with open(new_config_path, 'w') as f:
            f.write(yaml.dump(config_dict, default_flow_style=False))
    return None

def update_configfile(config_path, update_dict):
    # Careful! This function overwrites the config file.
    # Comments in the file are lost.
    with open(config_path, 'r+') as f:
        config_dict = yaml.safe_load(f)
        config_dict.update(**update_dict)
        f.write(yaml.dump(config_dict, default_flow_style=False))
    return None

def set_stage_inputs(stages, config_file='temp_config.yaml',
                     intput_namespace="STAGE_INPUT"):
    update_dict = {}
    for i, stage in enumerate(stages[:-1]):
        update_dict[intput_namespace] = read_stage_output(stage)
        update_configfile(config_path=os.path.join(working_dir, stages[i+1], config_file),
                          update_dict=update_dict)
    return None

def set_global_configs(stages, config_file='temp_config.yaml'):
    for stage in stages:
        update_configfile(config_path=os.path.join(working_dir, stage, config_file),
                          update_dict=config)
    return None

def get_stage(num):
    if num < len(STAGES):
        return STAGES[num]
    else:
        # temporary solution
        return ''

## Building the temp_config.yaml files
# create_temp_configs(STAGES)
# # overwrite stage configs with pipeline config parameters
# set_global_configs(STAGES)
# # write STAGE_OUTPUT into config of the following stage as STAGE_INPUT
# set_stage_inputs(STAGES)

subworkflow stage01:
    workdir:
        os.path.join(working_dir, get_stage(0))
    configfile:
        os.path.join(working_dir, get_stage(0), "temp_config.yaml")

subworkflow stage02:
    workdir:
        os.path.join(working_dir, get_stage(1))
    configfile:
        os.path.join(working_dir, get_stage(1), "temp_config.yaml")

subworkflow stage03:
    workdir:
        os.path.join(working_dir, get_stage(2))
    configfile:
        os.path.join(working_dir, get_stage(2), "temp_config.yaml")

subworkflow stage04:
    workdir:
        os.path.join(working_dir, get_stage(3))
    configfile:
        os.path.join(working_dir, get_stage(3), "temp_config.yaml")

subworkflow stage05:
    workdir:
        os.path.join(working_dir, get_stage(4))
    configfile:
        os.path.join(working_dir, get_stage(4), "temp_config.yaml")

def stage_input(wildcards):
        stage_num = [i for i, stage in enumerate(STAGES)
                                    if stage == wildcards.stage][0]
        if stage_num:
            return os.path.join(output_path, f'{STAGES[stage_num-1]}.done')
        else:
            return []

def stage_output(wildcards):
    if wildcards.stage == get_stage(0):
        return stage01(read_stage_output(wildcards.stage))
    elif wildcards.stage == get_stage(1):
        return stage02(read_stage_output(wildcards.stage))
    elif wildcards.stage == get_stage(2):
        return stage03(read_stage_output(wildcards.stage))
    elif wildcards.stage == get_stage(3):
        return stage04(read_stage_output(wildcards.stage))
    elif wildcards.stage == get_stage(4):
        return stage05(read_stage_output(wildcards.stage))
    else:
        raise InputError(f"Don't recognize stage {wildcards.stage}!")

rule all:
    input:
        last_stage = os.path.join(output_path, f'{STAGES[-1]}.done'),
        reports = expand(os.path.join(output_path, '{subworkflow_name}',
                                      'report.html'),
                         subworkflow_name=STAGES)
    shell:
        """
        rm */temp_config.yaml
        """

rule execute_stage:
    input:
        stage_input = stage_input,
        stage_output = stage_output,
        config = os.path.join(working_dir, '{stage}', "config.yaml")
    output:
        temp(os.path.join(output_path, '{stage}.done'))
    shell:
        """
        touch {output}
        """

rule create_report:
    input:
        clear = os.path.join(output_path, '{subworkflow_name}', 'report.clear'),
    output:
        report = os.path.join(output_path, '{subworkflow_name}', 'report.html')
    shell:
        """
        cd {wildcards.subworkflow_name}
        snakemake --configfile temp_config.yaml \
                  --report {output.report} || \
        echo "Creation of report for {wildcards.subworkflow_name} failed."
        """

rule clear_report:
    output:
        temp(os.path.join('{path}', 'report.clear'))
    shell:
        """
        rm -f "{wildcards.path}/report.html"
        touch "{output}"
        """
