configfile: "configfile.yaml"

import sys
sys.path.append('../')
from settings import working_dir, data_path, output_path
import numpy as np

FRAME_NUM_REGEX = config["FRAME_NUM_REGEX"]
CONTOUR_LIMIT = config["CONTOUR_LIMIT"]
CONTOUR_FRAME = config["CONTOUR_FRAME"]
MACRO_PIXEL_DIM = config["MACRO_PIXEL_DIM"]
NORMALIZE_BY = config["NORMALIZE_BY"]
FRAME_START = config["FRAME_START"]
FRAME_STOP = config["FRAME_STOP"]
IMG_PATH = config["IMG_PATH"]
SAMPLING_RATE = config["SAMPLING_RATE"]
PIXEL_SIZE = config["PIXEL_SIZE"]
SAVE_IMAGE_FORMAT = config["SAVE_IMAGE_FORMAT"]
CONTOUR_FRAME = config["CONTOUR_FRAME"]
BUTTER_LOWCUT = config["BUTTER_LOWCUT"]
BUTTER_HIGHCUT = config["BUTTER_HIGHCUT"]
BUTTER_ORDER = config["BUTTER_ORDER"]
MINIMA_THRESHOLD = config["MINIMA_THRESHOLD"]
MINIMA_WINDOWSIZE = config["MINIMA_WINDOWSIZE"]
TRANSITION_PHASE = config["TRANSITION_PHASE"]

# ToDo: write a parameter check function
# if '--nolock' not in sys.argv:
#     from check_parameters import check_parameters
#     check_parameters(config)

def input_images(location):
    def image_files(wildcards):
        return expand(os.path.join(location, '{image_path}', '{file_name}.tif'),
                      image_path=wildcards.image_path,
                      file_name=glob_wildcards(os.path.join(location,
                                '{image_path}', '{file_name}.tif')).file_name)
    return image_files


rule img_all:
    input:
        expand(os.path.join(output_path, '{image_path}', 'up_transitions.nix'), image_path = IMG_PATH),
        expand(os.path.join(output_path, '{image_path}', 'spectrum.npy'), image_path = IMG_PATH),
        expand(os.path.join(output_path, '{image_path}', 'preprocessed_images.mp4'), image_path = IMG_PATH),
        config = 'configfile.yaml'
    output:
        expand(os.path.join(output_path, '{image_path}', 'configfile.yaml'), image_path = IMG_PATH)
    shell:
        """
        echo {output} | xargs -n 1 cp {input.config}
        """

# rule all:
#     input:
#         expand(os.path.join(output_path, '{image_path}', 'configfile.yaml'), image_path = IMG_PATH)
#     shell:
#         """
#         touch scripts/img_to_neo.py
#         """


rule img_find_contour:
    input:
        image_nix = os.path.join(output_path, '{image_path}', 'images.nix'),
        script = 'scripts/img_find_contour.py'
    params:
        contour_limit = CONTOUR_LIMIT,
        contour_frame = CONTOUR_FRAME
    output:
        contour = os.path.join(output_path, '{image_path}', 'contour.npy'),
        mask = os.path.join(output_path, '{image_path}', 'mask.npy'),
        image = os.path.join(output_path, '{image_path}',
                             'contour.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --output_contour {output.contour} \
                              --output_mask {output.mask} \
                              --output_image {output.image} \
                              --contour_limit {params.contour_limit} \
                              --contour_frame {params.contour_frame}
        """


rule img_calculate_background:
    input:
        image_nix = os.path.join(output_path,
                                 '{image_path}', 'images.nix'),
        script = 'scripts/img_calculate_background.py'
    output:
        background = os.path.join(output_path,
                                  '{image_path}', 'background.npy'),
        image = os.path.join(output_path, '{image_path}',
                             'background.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --output_background {output.background} \
                              --output_image {output.image} \
        """

rule img_preprocessing:
    input:
        image_nix = os.path.join(output_path,
                                 '{image_path}', 'images.nix'),
        background = ancient(os.path.join(output_path,
                                  '{image_path}', 'background.npy')),
        mask = ancient(os.path.join(output_path, '{image_path}', 'mask.npy')),
        script = "scripts/img_preprocessing.py",
        configfile = "configfile.yaml"
    params:
        macro_pixel_dim = MACRO_PIXEL_DIM,
        normalize_by = NORMALIZE_BY
    output:
        os.path.join(output_path, '{image_path}', 'preprocessed_images.nix')
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --background {input.background} \
                              --mask {input.mask} \
                              --macro_pixel_dim {params.macro_pixel_dim} \
                              --normalize_by {params.normalize_by} \
                              --output {output} \
        """

rule img_plot_movie_frames:
    input:
        image_nix = os.path.join(output_path, '{image_path}',
                                 '{file}.nix'),
        script = "scripts/img_plot_movie_frames.py",
    params:
        frame_name = 'frame',
        frame_format = SAVE_IMAGE_FORMAT,
    output:
        frame_folder = directory(os.path.join(output_path,
                                              '{image_path}', '{file}_frames')),
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --frame_folder {output.frame_folder} \
                              --frame_format {params.frame_format} \
                              --frame_name {params.frame_name} \
        """

rule img_plot_movie:
    input:
        os.path.join(output_path, '{image_path}', '{file}_frames')
    output:
        os.path.join(output_path, '{image_path}', '{file}.mp4')
    params:
        frame_path = lambda wildcards, input: os.path.join(input[0],
                                                'frame_%05d.{}'\
                                                .format(SAVE_IMAGE_FORMAT)),
        quality = 0,
        scale_x = 1080,
        scale_y = 1080,
        fps = 15
    shell:
        """
        ffmpeg -y -framerate {params.fps} \
               -i {params.frame_path} -q {params.quality} \
               -crf {params.quality} \
               -vf scale={params.scale_x}:{params.scale_y} \
               {output}
        """

rule mp4_to_webm:
    input:
        '{file_path}.mp4'
    output:
        '{file_path}.webm'
    shell:
        """
        ffmpeg -i {input} -vcodec libvpx -acodec libvorbis {output}
        """



rule img_to_neo:
    input:
        images = input_images(data_path), #/{image_path}/*.tif
        script = 'scripts/img_to_neo.py'
    params:
        sampling_rate = SAMPLING_RATE, # Hz
        t_start = 0, # s
        pixel_size = PIXEL_SIZE, # mm
        frame_num_regex = [[FRAME_NUM_REGEX]]
    output:
        norm_signal = os.path.join(output_path, '{image_path}', 'images.nix')
    shell:
        """
        python {input.script} --image_files {input.images} \
                              --output {output} \
                              --sampling_rate {params.sampling_rate} \
                              --t_start {params.t_start} \
                              --pixel_size {params.pixel_size} \
                              --frame_num_regex {params.frame_num_regex}
        """

rule img_plot_spectrum:
    input:
        image_nix = os.path.join(output_path, '{image_path}',
                                 'preprocessed_images.nix'),
        script = "scripts/img_plot_spectrum.py"
    params:
        sampling_rate = SAMPLING_RATE,
        psd_freq_res = 0.1,
        psd_overlap = 0.8
    output:
        spectrum = os.path.join(output_path, '{image_path}', 'spectrum.npy'),
        spectrum_plot = os.path.join(output_path, '{image_path}',
                       'spectrum.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --out_spectrum {output.spectrum} \
                              --out_plot {output.spectrum_plot} \
                              --sampling_rate {params.sampling_rate} \
                              --psd_freq_res {params.psd_freq_res} \
                              --psd_overlap {params.psd_overlap} \
        """

rule img_up_detection:
    input:
        image_nix = os.path.join(output_path, '{image_path}',
                                 'preprocessed_images.nix'),
        script = "scripts/img_up_detection.py"
    params:
        # lowcut = BUTTER_LOWCUT,
        # highcut = BUTTER_HIGHCUT,
        # order = BUTTER_ORDER,
        # minima_threshold = MINIMA_THRESHOLD,
        # minima_windowsize = MINIMA_WINDOWSIZE
        transition_phase = TRANSITION_PHASE
    output:
        os.path.join(output_path, '{image_path}', 'up_transitions.nix')
    shell:
        """
        python {input.script} --image_file {input.image_nix} \
                              --out_signal {output} \
                              --transition_phase {params.transition_phase}
        """
                              # --lowcut {params.lowcut} \
                              # --highcut {params.highcut} \
                              # --order {params.order} \
                              # --minima_threshold {params.minima_threshold} \
                              # --minima_windowsize {params.minima_windowsize}


rule img_wavefront_velocity:
    input:
        waves = os.path.join(output_path, '{image_path}', 'up_transitions.nix'),
        contour = os.path.join(output_path, '{image_path}', 'contour.npy'),
        script = "scripts/img_calc_velocity.py"
    params:
        min_pixelfrac = 0.005,  # % of active pixels involved in wave front
        max_fiterror = 0.18,  # std of linear fit
        max_rotation = 0.12, # rad
        min_frames = 3 # number of sucessive frames showing a wave
    output:
        os.path.join(output_path, '{image_path}', 'wavefront_velocities.npy')
    shell:
        """
        python {input.script} --waves {input.waves} \
                              --output {output} \
                              --contour {input.contour} \
                              --min_pixelfrac {params.min_pixelfrac} \
                              --max_fiterror {params.max_fiterror} \
                              --max_rotation {params.max_rotation} \
                              --min_frames {params.min_frames}
        """


rule img_plot_signal:
    input:
        signal = os.path.join(output_path, '{image_path}',
                                    'up_transitions.nix'),
        script = "scripts/img_plot_signal.py"
    params:
        highcut = BUTTER_HIGHCUT,
        lowcut = BUTTER_LOWCUT
    output:
        os.path.join(output_path, '{image_path}',
                     'signal_pixel_{x}_{y}'+'.{}'.format(SAVE_IMAGE_FORMAT))
    shell:
        """
        python {input.script} --signal {input.signal} \
                              --output {output} \
                              --x {wildcards.x} \
                              --y {wildcards.y} \
                              --highcut {params.highcut} \
                              --lowcut {params.lowcut} \
        """
