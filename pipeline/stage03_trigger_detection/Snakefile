# Stage 03 Trigger Detection
import os
from pathlib import Path

configfile: Path('configs') / 'config_template.yaml'
include: Path() / '..' / 'utils' / 'Snakefile'

#### Housekeeping ####

def locate(str_list, string):
    if string in str_list:
        return [i for i, el in enumerate(str_list) if el == string][0]
    else:
        raise ValueError("Can't find rule '{}'! Please check the spelling \
                          and the config file.".format(string))

def filtered_triggers(wildcards):
    rule_list = config.TRIGGER_FILTER
    default_input = os.path.join(OUTPUT_DIR, config.DETECTION_BLOCK,
                                 'transitions.'+config.NEO_FORMAT),
    if hasattr(wildcards, 'rule_name'):
        idx = locate(rule_list, wildcards.rule_name)
        if idx:
            return os.path.join(OUTPUT_DIR, rule_list[idx-1],
                                rule_list[idx-1]+'.'+config.NEO_FORMAT)
    elif len(rule_list):
        return os.path.join(OUTPUT_DIR, rule_list[-1],
                            rule_list[-1]+'.'+config.NEO_FORMAT)
    return default_input

wildcard_constraints:
    file_name = '\w+',
    rule_name = '\w+'

localrules: all, check_input

#### UTILTY BLOCKS ####

rule all:
    input:
        check = os.path.join(OUTPUT_DIR, 'input.check'),
        # configfile = os.path.join('configs', f'config_{PROFILE}.yaml'),
        data = filtered_triggers,
        img = os.path.join(OUTPUT_DIR, 'plot_trigger_times')
    params:
        command = 'ln -s' if config.USE_LINK_AS_STAGE_OUTPUT else 'cp'
    output:
        data = os.path.join(OUTPUT_DIR, config.STAGE_OUTPUT)
    shell:
        """
        {params.command} "{input.data}" "{output.data}"
        """

# rule check_input:
#     priority: 10
#     input:
#         data = config.STAGE_INPUT,
#         script = os.path.join('scripts', 'check_input.py')
#     output:
#         os.path.join('{dir}', 'input.check')
#     shell:
#         """
#         {ADD_UTILS}
#         python3 "{input.script}" --data "{input.data}"
#         touch "{output}"
#         """

checkpoint plot_trigger_times:
    input:
        data = filtered_triggers,
        plot_script = os.path.join('scripts', 'plot_trigger_times.py')
    params:
        tstart = config.PLOT_TSTART,
        tstop = config.PLOT_TSTOP,
        plot_channels = config.PLOT_CHANNELS,
        filename = 'trigger_times_channel0'+config.PLOT_FORMAT
    output:
        img_dir = report(directory(os.path.join(OUTPUT_DIR, 'plot_trigger_times')),
                         patterns=["{img_name}."+config.PLOT_FORMAT])
    shell:
        """
        {ADD_UTILS}
        python3 "{input.plot_script}" --data "{input.data}" \
                                      --output_dir "{output.img_dir}" \
                                      --filename {params.filename} \
                                      --t_start {params.tstart} \
                                      --t_stop {params.tstop} \
                                      --channels {params.plot_channels} \
        """

#### DETECTION BLOCKS (choose one) ####

rule threshold:
    input:
        data = config.STAGE_INPUT,
        thresholds = os.path.join('{dir}', 'threshold',
                                  f'{config.THRESHOLD_METHOD}_thresholds.npy'),
        script = os.path.join('scripts', 'threshold.py')
    output:
        data = os.path.join('{dir}', 'threshold', 'transitions.'+config.NEO_FORMAT)
    shell:
        """
        {ADD_UTILS}
        python3 "{input.script}" --data "{input.data}" \
                                 --output "{output.data}" \
                                 --thresholds "{input.thresholds}"
        """

rule calc_thresholds_fixed:
# sub-rule of threshold
    input:
        data = config.STAGE_INPUT,
        script = os.path.join('scripts', 'calc_thresholds_fixed.py')
    params:
        threshold = config.FIXED_THRESHOLD
    output:
        array = os.path.join('{dir}', 'threshold', 'fixed_thresholds.npy')
    shell:
        """
        {ADD_UTILS}
        python3 "{input.script}" --data "{input.data}" \
                                 --output "{output.array}" \
                                 --threshold {params.threshold}
        """

rule calc_thresholds_fitted:
# sub-rule of threshold
    input:
        data = config.STAGE_INPUT,
        script = os.path.join('scripts', 'calc_thresholds_fitted.py')
    params:
        sigma_factor = config.SIGMA_FACTOR,
        fit_function = config.FIT_FUNCTION,
        bin_num = config.BIN_NUM,
        plot_channels = config.PLOT_CHANNELS,
        img_name = 'amplitudes_channel0.'+config.PLOT_FORMAT
    output:
        array = os.path.join('{dir}', 'threshold', 'fitted_thresholds.npy'),
        img_dir = report(directory(os.path.join('{dir}', 'threshold',
                                                'fitted_thresholds')),
                        patterns=["{img_name}"])
    shell:
        """
        {ADD_UTILS}
        python3 "{input.script}" --data "{input.data}" \
                                 --output "{output.array}" \
                                 --img_dir "{output.img_dir}" \
                                 --img_name {params.img_name} \
                                 --sigma_factor {params.sigma_factor} \
                                 --fit_function {params.fit_function} \
                                 --bin_num {params.bin_num} \
                                 --plot_channels {params.plot_channels}
        """

rule hilbert_phase:
    input:
        data = config.STAGE_INPUT,
        script = os.path.join('scripts', 'hilbert_phase.py')
    params:
        transition_phase = config.TRANSITION_PHASE,
        plot_channels = config.PLOT_CHANNELS,
        plot_tstart = config.PLOT_TSTART,
        plot_tstop = config.PLOT_TSTOP,
        img_name = 'hilbert_phase_channel0.'+config.PLOT_FORMAT
    output:
        data = os.path.join('{dir}', 'hilbert_phase', 'transitions.'+config.NEO_FORMAT),
        img_dir = report(directory(os.path.join('{dir}', 'hilbert_phase',
                                                'hilbert_phase_plots')),
                         patterns=['{img_name}.'+config.PLOT_FORMAT])
    shell:
        """
        {ADD_UTILS}
        python3 "{input.script}" --data "{input.data}" \
                                 --output "{output.data}" \
                                 --img_dir "{output.img_dir}" \
                                 --img_name {params.img_name} \
                                 --transition_phase {params.transition_phase} \
                                 --plot_channels {params.plot_channels} \
                                 --plot_tstart {params.plot_tstart} \
                                 --plot_tstop {params.plot_tstop}
        """

use rule template as minima with:
    input:
        data = config.STAGE_INPUT,
        script = Path('scripts') / 'minima.py'
    output:
        Path('{dir}') / 'minima' / f'transitions.{config.NEO_FORMAT}',
        img_dir = directory(Path('{dir}') / 'minima' / 'minima_plots')
    params:
        params('minima_persistence', 'min_peak_distance', 'maxima_threshold_fraction', 
               'maxima_threshold_window', 'num_interpolation_points', 
               'plot_channels', 'plot_tstart', 'plot_tstop',
                img_name='minima_channel0.'+config.PLOT_FORMAT, config=config),
        additional_outputs


#### FILTER BLOCKS (choose any) ####

rule remove_short_states:
    input:
        data = filtered_triggers,
        script = os.path.join('scripts', 'remove_short_states.py')
    params:
        min_up_duration = config.MIN_UP_DURATION,
        min_down_duration = config.MIN_DOWN_DURATION,
        remove_down_first = config.REMOVE_DOWN_FIRST
    output:
        data = os.path.join('{dir}', '{rule_name}',
                            'remove_short_states.'+config.NEO_FORMAT)
    shell:
        """
        {ADD_UTILS}
        python3 "{input.script}" --data "{input.data}" \
                                 --output "{output.data}" \
                                 --min_up_duration {params.min_up_duration} \
                                 --min_down_duration {params.min_down_duration} \
                                 --remove_down_first {params.remove_down_first} \
        """
