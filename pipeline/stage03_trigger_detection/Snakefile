# Stage 03 Trigger Detection

configfile: "config.yaml"
report: "report.rst"

import os
import sys
sys.path.append('../')
from settings import output_path

if 'INPUT_FILE' in config:
    stage_input = config["INPUT_FILE"]
else:
    stage_input = os.path.join(output_path, 'stage02_preprocessing',
                               'preprocessed_data.nix')

output_path = os.path.join(output_path, 'stage03_trigger_detection/')

neo_format = '.nix' # fixed! Do not change!
STAGE_OUTPUT = config["OUTPUT"]
USE_LINK_AS_STAGE_OUTPUT = config["USE_LINK_AS_STAGE_OUTPUT"]
PLOT_FORMAT = config["PLOT_FORMAT"]

TRANSFORMATION_BLOCKS = config["TRANSFORMATION_BLOCKS"]
DETECTION_BLOCK = config["DETECTION_BLOCK"]

MUA_HIGHPASS_FREQ = config["MUA_HIGHPASS_FREQ"]
MUA_LOWPASS_FREQ = config["MUA_LOWPASS_FREQ"]
logMUA_RATE = config["logMUA_RATE"]
FFT_SLICE = config["FFT_SLICE"]
PSD_OVERLAP = config["PSD_OVERLAP"]
PLOT_TSTART = config["PLOT_TSTART"]
PLOT_TSTOP = config["PLOT_TSTOP"]
PLOT_CHANNEL = config["PLOT_CHANNEL"]

THRESHOLD_METHOD = config["THRESHOLD_METHOD"]
FIXED_THRESHOLD = config["FIXED_THRESHOLD"]
FIT_FUNCTION = config["FIT_FUNCTION"]
BIN_NUM = config["BIN_NUM"]
SIGMA_FACTOR = config["SIGMA_FACTOR"]

TRANSITION_PHASE = config["TRANSITION_PHASE"]
MINIMA_ORDER = config["MINIMA_ORDER"]

QUALITY = config["QUALITY"]
SCALE_X = config["SCALE_X"]
SCALE_Y = config["SCALE_Y"]
FPS = config["FPS"]
BITRATE = config["BITRATE"]
COLORMAP = config["COLORMAP"]

# ToDo: outsource Transformation as subsection via include?

#### Housekeeping ####

def locate(str_list, string):
    if string in str_list:
        return [i for i, el in enumerate(str_list) if el == string][0]
    else:
        raise ValueError("Can't find rule '{}'! Please check the spelling "\
                       + "and the config file.".format(string))

def transformation_input_file(wildcards):
    if wildcards.rule_name == 'transformation':
        return os.path.join(output_path, 'transformation',
                            TRANSFORMATION_BLOCKS[-1],
                            TRANSFORMATION_BLOCKS[-1]+neo_format)
    else:
        idx = locate(TRANSFORMATION_BLOCKS, wildcards.rule_name)
        if idx:
            return os.path.join(output_path, 'transformation',
                                TRANSFORMATION_BLOCKS[idx-1],
                                TRANSFORMATION_BLOCKS[idx-1]+neo_format)
        else:
            return stage_input

def trigger_detection_input_file(wildcards):
    if len(TRANSFORMATION_BLOCKS):
        return os.path.join(output_path, 'transformation',
                            'transformed_signal'+neo_format)
    else:
        return stage_input

rule all:
    input:
        data = os.path.join(output_path, DETECTION_BLOCK, 'transitions'+neo_format),
        plot_script = 'scripts/plot_trigger_times.py',
    params:
        tstart = PLOT_TSTART,
        tstop = PLOT_TSTOP,
        channel = PLOT_CHANNEL,
        command = 'ln -s' if USE_LINK_AS_STAGE_OUTPUT else 'cp'
    output:
        data = os.path.join(output_path, STAGE_OUTPUT),
        img = report(os.path.join(output_path, DETECTION_BLOCK,
                                  'transitions'+PLOT_FORMAT))
    shell:
        """
        {params.command} "{input.data}" "{output.data}"
        python {input.plot_script} --data "{input.data}" \
                                   --output "{output.img}" \
                                   --t_start {params.tstart} \
                                   --t_stop {params.tstop} \
                                   --channel {params.channel}
        """

rule transformation:
    input:
        data = transformation_input_file,
        configfile = 'config.yaml',
        plot_script = 'scripts/plot_transformed_trace.py'
    params:
        plot_tstart = PLOT_TSTART,
        plot_tstop = PLOT_TSTOP,
        plot_channel = PLOT_CHANNEL,
        stage_input = stage_input
    output:
        data = os.path.join(output_path, '{rule_name}',
                            'transformed_signal'+neo_format),
        img = report(os.path.join(output_path, '{rule_name}',
                                  'transformed_trace_{}-{}s_channel{}{}'\
                                  .format(PLOT_TSTART, PLOT_TSTOP, PLOT_CHANNEL, PLOT_FORMAT)))
    shell:
        """
        cp "{input.data}" "{output.data}"
        python {input.plot_script} --data "{params.stage_input}" \
                                   --trans_data "{output.data}" \
                                   --output "{output.img}" \
                                   --t_start {params.plot_tstart} \
                                   --t_stop {params.plot_tstop} \
                                   --channel {params.plot_channel}
        """

#### Blocks ####

#### Transformation Blocks ####

rule logMUA_estimation:
    input:
        data = transformation_input_file,
        script = 'scripts/logMUA_estimation.py',
        plot_script = 'scripts/plot_transformed_trace.py'
    params:
        highpass_freq = MUA_HIGHPASS_FREQ,
        lowpass_freq = MUA_LOWPASS_FREQ,
        logMUA_rate = logMUA_RATE,
        fft_slice = FFT_SLICE,
        psd_overlap = PSD_OVERLAP,
        plot_tstart = PLOT_TSTART,
        plot_tstop = PLOT_TSTOP,
        plot_channel = PLOT_CHANNEL
    output:
        data = os.path.join(output_path, 'transformation', 'logMUA_estimation',
                            '{rule_name}'+neo_format),
        img = report(os.path.join(output_path, 'transformation', '{rule_name}',
                                  'logMUA_trace_{}-{}s_channel{}{}'\
                                  .format(PLOT_TSTART, PLOT_TSTOP, PLOT_CHANNEL, PLOT_FORMAT)))
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --output "{output.data}" \
                              --highpass_freq {params.highpass_freq} \
                              --lowpass_freq {params.lowpass_freq} \
                              --logMUA_rate {params.logMUA_rate} \
                              --fft_slice {params.fft_slice} \
                              --psd_overlap {params.psd_overlap}
        python {input.plot_script} --data "{input.data}" \
                                   --trans_data "{output.data}" \
                                   --output "{output.img}" \
                                   --tstart {params.plot_tstart} \
                                   --tstop {params.plot_tstop} \
                                   --channel {params.plot_channel}
        """

rule phase:
    input:
        data = transformation_input_file,
        script = 'scripts/phase_transform.py'
    output:
        data = os.path.join(output_path, 'transformation', 'phase',
                            '{rule_name}'+neo_format)
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --output "{output.data}"
        """

#### Detection Blocks ####

rule threshold:
    input:
        data = trigger_detection_input_file,
        thresholds = os.path.join(output_path, 'threshold',
                                  '{}_thresholds.npy'.format(THRESHOLD_METHOD)),
        script = 'scripts/threshold.py'
    output:
        data = os.path.join(output_path, 'threshold', 'transitions'+neo_format)
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --output "{output.data}" \
                              --thresholds "{input.thresholds}"
        """

rule calc_tresholds_fixed:
    input:
        data = trigger_detection_input_file,
        script = 'scripts/calc_thresholds_fixed.py'
    params:
        threshold = FIXED_THRESHOLD
    output:
        array = os.path.join(output_path, 'threshold', 'fixed_thresholds.npy')
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --output "{output.array}" \
                              --threshold {params.threshold}
        """

rule calc_tresholds_fitted:
    input:
        data = trigger_detection_input_file,
        script = 'scripts/calc_thresholds_fitted.py'
    params:
        sigma_factor = SIGMA_FACTOR,
        fit_function = FIT_FUNCTION,
        bin_num = BIN_NUM,
        plot_channel = PLOT_CHANNEL
    output:
        array = os.path.join(output_path, 'threshold', 'fitted_thresholds.npy'),
        img = report(os.path.join(output_path, 'threshold',
                     'amplitude_distribution_channel{}{}'\
                     .format(PLOT_CHANNEL, PLOT_FORMAT)))
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --output "{output.array}" \
                              --output_img "{output.img}" \
                              --sigma_factor {params.sigma_factor} \
                              --fit_function {params.fit_function} \
                              --bin_num {params.bin_num} \
                              --plot_channel {params.plot_channel}
        """

rule hilbert_phase:
    input:
        data = trigger_detection_input_file,
        script = 'scripts/hilbert_phase.py'
    params:
        transition_phase = TRANSITION_PHASE
    output:
        data = os.path.join(output_path, 'hilbert_phase', 'transitions'+neo_format)
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --output "{output.data}" \
                              --transition_phase {params.transition_phase}
        """

rule minima:
    input:
        data = trigger_detection_input_file,
        script = 'scripts/minima.py'
    params:
        order = MINIMA_ORDER
    output:
        data = os.path.join(output_path, 'minima', 'transitions'+neo_format)
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --output "{output.data}" \
                              --order {params.order}
        """

### Movie plotting rules
rule plot_movie_frames:
    input:
        data = os.path.join('{path}', '{file}.nix'),
        script = "scripts/plot_movie_frames.py",
    params:
        frame_name = 'frame',
        frame_format = PLOT_FORMAT,
        colormap = COLORMAP
    output:
        frame_folder = directory(os.path.join('{path}', '{file}_frames')),
    shell:
        """
        python {input.script} --data "{input.data}" \
                              --frame_folder "{output.frame_folder}" \
                              --frame_format {params.frame_format} \
                              --frame_name {params.frame_name} \
                              --colormap {params.colormap}
        """

rule plot_movie:
    input:
        os.path.join('{path}', '{file}_frames')
    output:
        os.path.join('{path}', '{file}.mp4')
    params:
        frame_path = lambda wildcards, input: os.path.join(input[0],
                                                'frame_%05d{}'\
                                                .format(PLOT_FORMAT)),
        quality = QUALITY,
        scale_x = SCALE_X,
        scale_y = SCALE_Y,
        bitrate = BITRATE,
        fps = FPS
    shell:
        """
        ffmpeg -y -framerate {params.fps} \
               -i "{params.frame_path}" \
               -crf {params.quality} \
               -vb {params.bitrate} \
               -vcodec libx264 \
               -vf scale={params.scale_x}:{params.scale_y} \
               "{output}"
        """

rule mp4_to_webm:
    input:
        '{path}.mp4'
    output:
        '{path}.webm'
    shell:
        """
        ffmpeg -i "{input}" -vcodec libvpx -acodec libvorbis "{output}"
        """
